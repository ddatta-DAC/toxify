from itertools import groupby
import math


def fasta_iter(fasta_name):
    fh = open(fasta_name)
    faiter = (x[1] for x in groupby(fh, lambda line: line[0] == ">"))
    for header in faiter:
        headerStr = header.__next__()[1:].strip().split()[0]#Entire line, add .split[0] for just first column
        seq = "".join(s.strip() for s in faiter.__next__())
        yield (headerStr, seq)
def distance(x1,y1,x2,y2):
    d = math.sqrt((x1-x2)**2 + (y1-y2)**2)
    return d

def makeSquare(size,scale):
    midpoint = size/2
    Dist2center = distance(0,0,midpoint,midpoint)
    # print(Dist2center)
    top_pointDist2center = Dist2center - Dist2center*(scale)
    # print(Dist2center,scale)
    top_point_coord = int(top_pointDist2center/math.sqrt(2))

    bottomDist2center =  Dist2center + Dist2center*(scale)
    bottom_point_coord = int(bottomDist2center/math.sqrt(2))
    return (top_point_coord, top_point_coord, bottom_point_coord, bottom_point_coord)

SAMPLES, = glob_wildcards("{sample}.fa")


rule final:
    # input: expand("{sample}.blastout",sample=SAMPLES)
    # input: dynamic("{header}.aln")
    input:"pssm.csv"

rule diamond:
    input:
        expand("{sample}.fa",sample=SAMPLES)
    output:
        expand("{sample}.blastout",sample=SAMPLES)
    threads:100
    shell:
        "diamond blastp -d /home/brewerlab/nr_database/diamond_db.dmnd -q {input} -o {output} -p {threads}   -f 6 sseqid sseq qseqid qseq  -k 1000 --unal 1"

rule blast2fa:
    input:
        expand("{sample}.blastout",sample=SAMPLES),
        expand("{sample}.fa",sample=SAMPLES)
    output:
        dynamic("pssm_dir/alignments/{header}.fasta")
    run:

        qdict = {}
        for ff in fasta_iter(input[1]):
            headerStr, seq = ff
            qdict[headerStr] = seq

        used_dict = {}

        with open(input[0]) as f:
            for line in f:


                row = line.split()
                with open("pssm_dir/"+row[2].replace("|","_")+".fasta","a") as out:
                    if row[2] not in used_dict:
                        used_dict[row[2]] = True
                        out.write(">"+row[2]+"\n")
                        out.write(qdict[row[2]]+"\n")
                    out.write(">"+row[0]+"\n")
                    out.write(row[1]+"\n")
rule mafft:
    input:
        "pssm_dir/alignments/{header}.fasta"
    output:
        "pssm_dir/alignments/{header}.aln"
    shell:
        "mafft --auto --thread -1 {input} > {output} || mafft --auto --thread -1 --anysymbol {input} > {output}"

rule align2pssm:
    input:
        "pssm_dir/alignments/{header}.aln"
    output:
        "pssm_dir/alignments/{header}.pssm"
    run:
        line1 = True
        line2write =""

        qseq = {}
        sseq = { "A":{},
                "C":{},
                "D":{},
                "E":{},
                "F":{},
                "G":{},
                "H":{},
                "I":{},
                "K":{},
                "L":{},
                "M":{},
                "N":{},
                "P":{},
                "Q":{},
                "R":{},
                "S":{},
                "T":{},
                "V":{},
                "W":{},
                "Y":{}

        }
        with open(output[0]) as out:
            for ff in fasta_iter(input):
                headerStr, seq = ff
                if line1:
                    for num in range(len(seq)):
                        if seq[num] != "-":
                            qseq[num] = seq[num]
                    line1 = False
                else:
                    for num in range(len(seq)):
                        if num in qseq:
                            if seq[num] != "-":
                                try:

                                    try:
                                        sseq[seq[num]][num] +=1
                                    except:
                                        sseq[seq[num]][num] = 1
                                except:
                                    0

            # print("\t", end="")
            line2write +="\t"
            for i in sorted(qseq.keys()):
                # print(qseq[i]+"\t", end="")
                line2write+=str(qseq[i]+"\t")

            # print()
            out.write(line2write+"\n")
            # for i in sorted(sseq.keys()):
            #     print(str(i)+"\t", end="")
            #     for j in sorted(sseq[i].keys()):
            #         print(str(j)+"\t", end="")
            #     print()

            for i in sseq:
                # print(i+"\t",end="")
                line2write +=str(i)+"\t"
                for j in sorted(qseq.keys()):
                    try:
                        print(str(sseq[i][j])+"\t",end="")
                        line2write+=str(sseq[i][j])+"\t"
                    except:
                        # print("0\t",end="")
                        line2write+="0\t"
                # print()
                out.write(line2write+"\t")



rule pssm2mat:
    input:
        dynamic("pssm_dir/alignments/{header}.pssm")
    output:
        "pssm.csv"
    run:


        # print(math.log(10,10))
        line1 = True
        top_dict = {}
        pair_dict ={}
        aa_count = {}
        top_count = {}
        tot_aa = 0
        with open(input) as f:
            for line in f:
                row = line.strip().split()
                if line1:
                    for i in range(len(row)):
                        top_dict[i+1] = row[i]
                    line1=False
                else:
                    for i in range(len(row)):

                        if i in top_dict :
                            # print(row[0],top_dict[i],row[i])
                            try:
                                pair_dict[top_dict[i]+row[0]]+= int(row[i])
                            except:
                                pair_dict[top_dict[i]+row[0]] = int(row[i])
                            try:
                                aa_count[row[0]] += int(row[i])
                            except:
                                aa_count[row[0]] = int(row[i])
                            try:
                                top_count[top_dict[i]]+=int(row[i])
                            except:
                                top_count[top_dict[i]]=int(row[i])

                            tot_aa += int(row[i])

        # print(pair_dict)
        # print("\n\n\n\n\n\n\n\n")
        aa_prob = {}
        for i in aa_count:
            aa_prob[i] = aa_count[i]/tot_aa
        aa = "ACDEFGHIKLMNPQRSTVWY"
        # print(" A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V  B  Z  X")
        line2write =""
        # print( "A R N D C Q E G H I L K M F P S T W Y V B Z X")
        # print(line2write)
        with open("pssm.csv") as out:

            for row in aa:
                # print(row+" ",end="")
                # line2write+=row+" "
                for col in aa:

                    # print(row+col,end='n')

                    try:
                        frequency = pair_dict[row+col]
                        # try:
                        # prob = frequency/1000
                        p_i = aa_prob[row]
                        q_j = aa_prob[col]
                        p_ij = (frequency/aa_count[col]) * (frequency/top_count[row])
                        s_ij = (1/0.75)*math.log(p_ij/(p_i*q_j),2)

                        # except:si
                        #     print("ERROR",row)
                        # print(str(int(s_ij))+" ",end="")
                        line2write+=str(s_ij)+","
                        # print(str(s_ij)+" ",end="")
                    except:
                        # print("na"+str(q_j)+" ",end="")
                        # print("0 ",end="")
                        line2write+="0,"
            print(line2write[:-1])
            out.write(line2write[:-1]+"\n")
            # print("\n\n\n\n\n\n\n")

                # print()
            # print(tot_aa)
            # print(aa_count)
            # print(top_count)
            #
            # print(pair_dict["WW"])

rule splitSeqs:
    input:
        "pssm_dir/alignments/{header}.fasta"
    output:
        "sequences/{header}.seq"
    shell:
        "head -n 1 {input} > {output}"

rule seq2png:
    input:
        "sequences/{header}.seq"
    output:
        "seq_pics/{header}.png"
    conda: "envs/pil.yaml"
    run:
        import PIL.ImageDraw as ImageDraw,PIL.Image as Image, PIL.ImageShow as ImageShow
        scale_factor = 360/20
        seqDict = {
            "A":(scale_factor*0,scale_factor*1),
            "C":(scale_factor*1,scale_factor*2),
            "D":(scale_factor*2,scale_factor*3),
            "E":(scale_factor*3,scale_factor*4),
            "F":(scale_factor*4,scale_factor*5),
            "G":(scale_factor*5,scale_factor*6),
            "H":(scale_factor*6,scale_factor*7),
            "I":(scale_factor*7,scale_factor*8),
            "K":(scale_factor*8,scale_factor*9),
            "L":(scale_factor*9,scale_factor*10),
            "M":(scale_factor*10,scale_factor*11),
            "N":(scale_factor*11,scale_factor*12),
            "P":(scale_factor*12,scale_factor*13),
            "Q":(scale_factor*13,scale_factor*14),
            "R":(scale_factor*14,scale_factor*15),
            "S":(scale_factor*15,scale_factor*16),
            "T":(scale_factor*16,scale_factor*17),
            "V":(scale_factor*17,scale_factor*18),
            "W":(scale_factor*18,scale_factor*19),
            "Y":(scale_factor*19,scale_factor*20)
            }
        num = 1000
        midpoint = num/2

        # sequence_iterator = fasta_iter(sys.argv[1])
        sequence_iterator = fasta_iter(input)
        for ff in sequence_iterator:
            image = Image.new('RGB', (num, num), 'white')
            draw = ImageDraw.Draw(image)
            draw.ellipse((0, 0, num, num), 'white', 'black')  # made this a little smaller..
            headerStr, seq = ff
            for aa in range(len(seq)):


                this_square = makeSquare(num,float(aa)/len(seq))
                # print(this_square)
                try:
                    draw.arc(this_square, seqDict[seq[aa]][0], seqDict[seq[aa]][1], 'black')  # draw an arc in black
                except:
                    0 #print("NO")

            image.save(output[0],"PNG")
